{
  "address": "0x6E2631aF80bF7a9cEE83F590eE496bCc2E40626D",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "key",
          "type": "address"
        }
      ],
      "name": "SessionKeyRevoked",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_packed",
          "type": "bytes"
        }
      ],
      "name": "parseDataAndSignature",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_key",
          "type": "address"
        }
      ],
      "name": "revokeSessionKey",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_key",
          "type": "address"
        }
      ],
      "name": "revoked",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "callGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "verificationGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxPriorityFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct UserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "userOpHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "missingAccountFunds",
          "type": "uint256"
        }
      ],
      "name": "validatePluginData",
      "outputs": [
        {
          "internalType": "bool",
          "name": "validated",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x47c6c345ed279550cff6a4f9d03c828a2a91d687fe3efa4a30a4cf959bb74a6d",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x8d8a9Cf53b7D95C148cB159384D249F8FB68db3f",
    "contractAddress": null,
    "transactionIndex": 20,
    "gasUsed": "1716069",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000008000000000000000000000000000000000000000000020000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000008000004000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000041000000000000000000000000000000100000000000000000000000000000000000000000000800000000000000000000000000100000",
    "blockHash": "0xcdaf96edb2f94217be6eaa18c699362dd1ffcd7bf5eb1727ba5f78259785d6d4",
    "transactionHash": "0x47c6c345ed279550cff6a4f9d03c828a2a91d687fe3efa4a30a4cf959bb74a6d",
    "logs": [
      {
        "transactionIndex": 20,
        "blockNumber": 41756616,
        "transactionHash": "0x47c6c345ed279550cff6a4f9d03c828a2a91d687fe3efa4a30a4cf959bb74a6d",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000008d8a9cf53b7d95c148cb159384d249f8fb68db3f",
          "0x000000000000000000000000b2dd091ea6e591d62f565d7a18ce2a7640add227"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000b6e6ab7ea6dc000000000000000000000000000000000000000000000000013a3e29fc746cb7790000000000000000000000000000000000000000000005dc18ef5d92af3c9cdb00000000000000000000000000000000000000000000000139874350f5c5db790000000000000000000000000000000000000000000005dc19a6443e2de378db",
        "logIndex": 211,
        "blockHash": "0xcdaf96edb2f94217be6eaa18c699362dd1ffcd7bf5eb1727ba5f78259785d6d4"
      }
    ],
    "blockNumber": 41756616,
    "cumulativeGasUsed": "26223434",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "d5c4a417af7f759d03a3c7da438dc2be",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"key\",\"type\":\"address\"}],\"name\":\"SessionKeyRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_packed\",\"type\":\"bytes\"}],\"name\":\"parseDataAndSignature\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_key\",\"type\":\"address\"}],\"name\":\"revokeSessionKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_key\",\"type\":\"address\"}],\"name\":\"revoked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"missingAccountFunds\",\"type\":\"uint256\"}],\"name\":\"validatePluginData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"validated\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/plugin/ZeroDevSessionKeyPlugin.sol\":\"ZeroDevSessionKeyPlugin\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[\":@openzeppelin/=lib/openzeppelin-contracts/\",\":account-abstraction/=lib/account-abstraction/contracts/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\"]},\"sources\":{\"lib/account-abstraction/contracts/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * returned data from validateUserOp.\\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\\n * @param aggregator - address(0) - the account validated the signature by itself.\\n *              address(1) - the account failed to validate the signature.\\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\\n * @param validAfter - this UserOp is valid only after this timestamp.\\n * @param validaUntil - this UserOp is valid only up to this timestamp.\\n */\\n    struct ValidationData {\\n        address aggregator;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n    }\\n\\n//extract sigFailed, validAfter, validUntil.\\n// also convert zero validUntil to type(uint48).max\\n    function _parseValidationData(uint validationData) pure returns (ValidationData memory data) {\\n        address aggregator = address(uint160(validationData));\\n        uint48 validUntil = uint48(validationData >> 160);\\n        if (validUntil == 0) {\\n            validUntil = type(uint48).max;\\n        }\\n        uint48 validAfter = uint48(validationData >> (48 + 160));\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n// intersect account and paymaster ranges.\\n    function _intersectTimeRange(uint256 validationData, uint256 paymasterValidationData) pure returns (ValidationData memory) {\\n        ValidationData memory accountValidationData = _parseValidationData(validationData);\\n        ValidationData memory pmValidationData = _parseValidationData(paymasterValidationData);\\n        address aggregator = accountValidationData.aggregator;\\n        if (aggregator == address(0)) {\\n            aggregator = pmValidationData.aggregator;\\n        }\\n        uint48 validAfter = accountValidationData.validAfter;\\n        uint48 validUntil = accountValidationData.validUntil;\\n        uint48 pmValidAfter = pmValidationData.validAfter;\\n        uint48 pmValidUntil = pmValidationData.validUntil;\\n\\n        if (validAfter < pmValidAfter) validAfter = pmValidAfter;\\n        if (validUntil > pmValidUntil) validUntil = pmValidUntil;\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp\\n * @param data - the ValidationData to pack\\n */\\n    function _packValidationData(ValidationData memory data) pure returns (uint256) {\\n        return uint160(data.aggregator) | (uint256(data.validUntil) << 160) | (uint256(data.validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp, when not using an aggregator\\n * @param sigFailed - true for signature failure, false for success\\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\\n * @param validAfter first timestamp this UserOperation is valid\\n */\\n    function _packValidationData(bool sigFailed, uint48 validUntil, uint48 validAfter) pure returns (uint256) {\\n        return (sigFailed ? 1 : 0) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\",\"keccak256\":\"0x591c87519f7155d1909210276b77925ab2722a99b7b5d5649aecc36ebbdb045a\",\"license\":\"GPL-3.0\"},\"lib/account-abstraction/contracts/interfaces/IAccount.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\ninterface IAccount {\\n\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp the operation that is about to be executed.\\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\\n     *      The excess is left as a deposit in the entrypoint, for future calls.\\n     *      can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\"\\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\\n     * @return validationData packaged ValidationData structure. use `_packValidationData` and `_unpackValidationData` to encode and decode\\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\\n     *         otherwise, an address of an \\\"authorizer\\\" contract.\\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n     *      <6-byte> validAfter - first timestamp this operation is valid\\n     *      If an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\\n    external returns (uint256 validationData);\\n}\\n\",\"keccak256\":\"0x556a0e5980de18e90b115553ed502408155ba35f58642823010d9288047bc418\",\"license\":\"GPL-3.0\"},\"lib/account-abstraction/contracts/interfaces/IAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n\\n    /**\\n     * validate aggregated signature.\\n     * revert if the aggregated signature does not match the given list of operations.\\n     */\\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature) external view;\\n\\n    /**\\n     * validate signature of a single userOp\\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp the userOperation received from the user.\\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\\n     *    (usually empty, unless account and aggregator support some kind of \\\"multisig\\\"\\n     */\\n    function validateUserOpSignature(UserOperation calldata userOp)\\n    external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation\\n     * @param userOps array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature the aggregated signature\\n     */\\n    function aggregateSignatures(UserOperation[] calldata userOps) external view returns (bytes memory aggregatedSignature);\\n}\\n\",\"keccak256\":\"0x060e9ddb0152250c269ba0640dc5753834ac44cf182a2837d508c0c529cae26a\",\"license\":\"GPL-3.0\"},\"lib/account-abstraction/contracts/interfaces/IEntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./UserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n\\n    /***\\n     * An event emitted after each successful request\\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request.\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\\n     */\\n    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);\\n\\n    /**\\n     * account \\\"sender\\\" was deployed.\\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender the account that is deployed\\n     * @param factory the factory used to deploy this account (in the initCode)\\n     * @param paymaster the paymaster used by this UserOp\\n     */\\n    event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param userOpHash the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);\\n\\n    /**\\n     * an event emitted by handleOps(), before starting the execution loop.\\n     * any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * signature aggregator used by the following UserOperationEvents within this bundle.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param reason - revert reason\\n     *      The string starts with a unique code \\\"AAmn\\\", where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *      so a failure can be attributed to the correct entity.\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    /**\\n     * Successful result from simulateValidation.\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     */\\n    error ValidationResult(ReturnInfo returnInfo,\\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\\n\\n    /**\\n     * Successful result from simulateValidation, if the account returns a signature aggregator\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\\n     */\\n    error ValidationResultWithAggregation(ReturnInfo returnInfo,\\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo,\\n        AggregatorStakeInfo aggregatorInfo);\\n\\n    /**\\n     * return value of getSenderAddress\\n     */\\n    error SenderAddressResult(address sender);\\n\\n    /**\\n     * return value of simulateHandleOp\\n     */\\n    error ExecutionResult(uint256 preOpGas, uint256 paid, uint48 validAfter, uint48 validUntil, bool targetSuccess, bytes targetResult);\\n\\n    //UserOps handled, per aggregator\\n    struct UserOpsPerAggregator {\\n        UserOperation[] userOps;\\n\\n        // aggregator address\\n        IAggregator aggregator;\\n        // aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external;\\n\\n    /**\\n     * gas and return values during simulation\\n     * @param preOpGas the gas used for validation (including preValidationGas)\\n     * @param prefund the required prefund for this operation\\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        bool sigFailed;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * returned aggregated signature info.\\n     * the aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address aggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n\\n    /**\\n     * simulate full execution of a UserOperation (including both validation and target execution)\\n     * this method will always revert with \\\"ExecutionResult\\\".\\n     * it performs full validation of the UserOperation, but ignores signature error.\\n     * an optional target address is called after the userop succeeds, and its value is returned\\n     * (before the entire call is reverted)\\n     * Note that in order to collect the the success/failure of the target call, it must be executed\\n     * with trace enabled to track the emitted events.\\n     * @param op the UserOperation to simulate\\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\\n     *        are set to the return from that call.\\n     * @param targetCallData callData to pass to target address\\n     */\\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external;\\n}\\n\\n\",\"keccak256\":\"0x3a90bf308819ed125fa4202f880999caff8a8686633b8ddb79a30ca240d5b8f8\",\"license\":\"GPL-3.0\"},\"lib/account-abstraction/contracts/interfaces/INonceManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\ninterface INonceManager {\\n\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(address sender, uint192 key)\\n    external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\\n\",\"keccak256\":\"0x509871e6c63663cdcc3eba19920fe84e991f38b289b1377ac3c3a6d9f22d7e12\",\"license\":\"GPL-3.0\"},\"lib/account-abstraction/contracts/interfaces/IStakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n\\n    event Deposited(\\n        address indexed account,\\n        uint256 totalDeposit\\n    );\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /// Emitted when stake or unstake delay are modified\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(\\n        address indexed account,\\n        uint256 withdrawTime\\n    );\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit the entity's deposit\\n     * @param staked true if this entity is staked.\\n     * @param stake actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 10^15 eth\\n     *    48 bit for full timestamp\\n     *    32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    //API struct used by getStakeInfo and simulateValidation\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /// @return info - full deposit information of given account\\n    function getDepositInfo(address account) external view returns (DepositInfo memory info);\\n\\n    /// @return the deposit (for gas payment) of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) external payable;\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\\n}\\n\",\"keccak256\":\"0xd227b02888cd4ac68daebcdfd992ec00f9fff66fa3b3bb16f656cd582fa3480f\",\"license\":\"GPL-3.0-only\"},\"lib/account-abstraction/contracts/interfaces/UserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport {calldataKeccak} from \\\"../core/Helpers.sol\\\";\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request.\\n     * @param nonce unique value the sender uses to verify it is not a replay.\\n     * @param initCode if set, the account contract will be created by this constructor/\\n     * @param callData the method call to execute on this account.\\n     * @param callGasLimit the gas limit passed to the callData method call.\\n     * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n     * @param maxFeePerGas same as EIP-1559 gas parameter.\\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n     * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n     */\\n    struct UserOperation {\\n\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes paymasterAndData;\\n        bytes signature;\\n    }\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {data := calldataload(userOp)}\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n    unchecked {\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        if (maxFeePerGas == maxPriorityFeePerGas) {\\n            //legacy mode (for networks that don't support basefee opcode)\\n            return maxFeePerGas;\\n        }\\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n    }\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        uint256 callGasLimit = userOp.callGasLimit;\\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            callGasLimit, verificationGasLimit, preVerificationGas,\\n            maxFeePerGas, maxPriorityFeePerGas,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x61374003361059087fdcf17967a7bba052badeaf5c7f0ae689166f8aafd3a45c\",\"license\":\"GPL-3.0\"},\"lib/openzeppelin-contracts/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0xda898fa084aa1ddfdb346e6a40459e00a59d87071cce7c315a46d648dd71d0ba\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\",\"keccak256\":\"0x948d8b2d18f38141ec78c5229d770d950ebc781ed3f44cc9e3ccbb9fded5846a\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd466e8b07f4c6220eac16da5127f3ff142e65f0c15c03c7d38f257b02c8585e1\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"src/plugin/IPlugin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"account-abstraction/interfaces/UserOperation.sol\\\";\\n\\ninterface IPlugin {\\n    function validatePluginData(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\\n        external\\n        returns (bool);\\n}\\n\",\"keccak256\":\"0xe560c14d4055e404a78ea0984006255a5b4d6acf29859de2f690520abf06a6a2\",\"license\":\"MIT\"},\"src/plugin/ZeroDevBasePlugin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\\\";\\nimport \\\"account-abstraction/interfaces/IAccount.sol\\\";\\nimport \\\"account-abstraction/interfaces/IEntryPoint.sol\\\";\\nimport \\\"./IPlugin.sol\\\";\\nabstract contract ZeroDevBasePlugin is IPlugin, EIP712 {\\n    function validatePluginData(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\\n        external\\n        override\\n        returns (bool validated)\\n    {\\n        // data offset starts at 97\\n        (bytes calldata data, bytes calldata signature) = parseDataAndSignature(userOp.signature[97:]);\\n        validated = _validatePluginData(userOp, userOpHash, data, signature);\\n    }\\n\\n    function _validatePluginData(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) internal virtual returns (bool success);\\n\\n    function parseDataAndSignature(bytes calldata _packed)\\n        public\\n        pure\\n        returns (bytes calldata data, bytes calldata signature)\\n    {\\n        uint256 dataPosition = uint256(bytes32(_packed[0:32]));\\n        uint256 dataLength = uint256(bytes32(_packed[dataPosition:dataPosition + 32]));\\n        uint256 signaturePosition = uint256(bytes32(_packed[32:64]));\\n        uint256 signatureLength = uint256(bytes32(_packed[signaturePosition:signaturePosition + 32]));\\n        data = _packed[dataPosition + 32:dataPosition + 32 + dataLength];\\n        signature = _packed[signaturePosition + 32:signaturePosition + 32 + signatureLength];\\n\\n        require(dataPosition + 64 + ((dataLength) / 32) * 32 == signaturePosition, \\\"invalid data\\\");\\n        require(signaturePosition + 64 + ((signatureLength) / 32) * 32 == _packed.length, \\\"invalid signature\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x600b768ba7d0766b2968c0d9bd6cd21154f14694eeb1e1a745d110d0fcb854e8\",\"license\":\"MIT\"},\"src/plugin/ZeroDevSessionKeyPlugin.sol\":{\"content\":\"//SPDX-License-Identifier: GPL\\npragma solidity ^0.8.7;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./ZeroDevBasePlugin.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\\\";\\nusing ECDSA for bytes32;\\n/**\\n * Main EIP4337 module.\\n * Called (through the fallback module) using \\\"delegate\\\" from the GnosisSafe as an \\\"IAccount\\\",\\n * so must implement validateUserOp\\n * holds an immutable reference to the EntryPoint\\n */\\n\\nstruct ZeroDevSessionKeyStorageStruct {\\n    mapping(address => bool) revoked;\\n}\\n\\ncontract ZeroDevSessionKeyPlugin is ZeroDevBasePlugin {\\n    // return value in case of signature failure, with no time-range.\\n    // equivalent to packSigTimeRange(true,0,0);\\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\\n\\n    event SessionKeyRevoked(address indexed key);\\n\\n    constructor() EIP712(\\\"ZeroDevSessionKeyPlugin\\\", \\\"0.0.1\\\") {}\\n\\n    function getPolicyStorage() internal pure returns (ZeroDevSessionKeyStorageStruct storage s) {\\n        bytes32 position = bytes32(uint256(keccak256(\\\"zero-dev.account.eip4337.sessionkey\\\")) - 1);\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n\\n    // revoke session key\\n    function revokeSessionKey(address _key) external {\\n        getPolicyStorage().revoked[_key] = true;\\n        emit SessionKeyRevoked(_key);\\n    }\\n\\n    function revoked(address _key) external view returns (bool) {\\n        return getPolicyStorage().revoked[_key];\\n    }\\n\\n    function _validatePluginData(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) internal view override returns (bool) {\\n        address sessionKey = address(bytes20(data[0:20]));\\n        require(!getPolicyStorage().revoked[sessionKey], \\\"session key revoked\\\");\\n        bytes32 merkleRoot = bytes32(data[20:52]);\\n        if(merkleRoot == bytes32(0)) {\\n            // means this session key has sudo permission\\n            signature = signature[33:98];\\n        } else {\\n            uint8 leafLength = uint8(signature[0]);\\n            bytes32[] memory proof;\\n            bytes32 leaf;\\n            if(leafLength == 20) {\\n                leaf = keccak256(signature[1:21]);\\n                proof = abi.decode(signature[86:], (bytes32[]));\\n                require(keccak256(userOp.callData[16:36]) == keccak256(signature[1:21]), \\\"invalid session key\\\");\\n                signature = signature[21:86];\\n            } else if(leafLength == 24) {\\n                leaf = keccak256(signature[1:25]);\\n                proof = abi.decode(signature[90:], (bytes32[]));\\n                require(keccak256(userOp.callData[16:36]) == keccak256(signature[1:21]), \\\"invalid session key\\\");\\n                uint256 offset = uint256(bytes32(userOp.callData[68:100]));\\n                bytes calldata sig = userOp.callData[offset + 36: offset + 40];\\n                require(keccak256(sig) == keccak256(signature[21:25]));\\n                signature = signature[25:90];\\n            }\\n            require(MerkleProof.verify(proof, merkleRoot, leaf), \\\"invalide merkle root\\\");\\n        }\\n        bytes32 digest = _hashTypedDataV4(\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"Session(bytes32 userOpHash,uint256 nonce)\\\"), // we are going to trust plugin for verification\\n                    userOpHash,\\n                    userOp.nonce\\n                )\\n            )\\n        );\\n        address recovered = digest.recover(signature);\\n        require(recovered == sessionKey, \\\"account: invalid signature\\\");\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x7463f6b16e3dacf9d618a25e7cb6e12e210ff96682051c62d5a5d6e9243adb30\",\"license\":\"GPL\"}},\"version\":1}",
  "bytecode": "0x6101406040523480156200001257600080fd5b506040518060400160405280601781526020017f5a65726f44657653657373696f6e4b6579506c7567696e0000000000000000008152506040518060400160405280600581526020017f302e302e3100000000000000000000000000000000000000000000000000000081525060008280519060200120905060008280519060200120905060007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90508260e081815250508161010081815250504660a08181525050620000e88184846200013760201b60201c565b608081815250503073ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff168152505080610120818152505050505050506200024b565b6000838383463060405160200162000154959493929190620001ee565b6040516020818303038152906040528051906020012090509392505050565b6000819050919050565b620001888162000173565b82525050565b6000819050919050565b620001a3816200018e565b82525050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000620001d682620001a9565b9050919050565b620001e881620001c9565b82525050565b600060a0820190506200020560008301886200017d565b6200021460208301876200017d565b6200022360408301866200017d565b62000232606083018562000198565b620002416080830184620001dd565b9695505050505050565b60805160a05160c05160e0516101005161012051611e016200029b6000396000610bac01526000610bee01526000610bcd01526000610b0201526000610b5801526000610b810152611e016000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806384f4fc6a14610051578063970aa9ad1461006d5780639e2045ce146100a0578063fa01dc06146100d0575b600080fd5b61006b60048036038101906100669190610fd2565b610100565b005b61008760048036038101906100829190611064565b6101a7565b604051610097949392919061110f565b60405180910390f35b6100ba60048036038101906100b591906111db565b6103ba565b6040516100c79190611265565b60405180910390f35b6100ea60048036038101906100e59190610fd2565b61040f565b6040516100f79190611265565b60405180910390f35b600161010a61046e565b60000160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508073ffffffffffffffffffffffffffffffffffffffff167f17c796fb82086b3c9effaec517342e5ca9ed8fd78c339137ec082f748ab60cbe60405160405180910390a250565b3660003660008086866000906020926101c29392919061128a565b906101cd91906112dd565b60001c90506000878783906020856101e5919061136b565b926101f29392919061128a565b906101fd91906112dd565b60001c9050600088886020906040926102189392919061128a565b9061022391906112dd565b60001c905060008989839060208561023b919061136b565b926102489392919061128a565b9061025391906112dd565b60001c90508989602086610267919061136b565b9085602088610276919061136b565b610280919061136b565b9261028d9392919061128a565b9750975089896020846102a0919061136b565b90836020866102af919061136b565b6102b9919061136b565b926102c69392919061128a565b9550955081602080856102d991906113ce565b6102e391906113ff565b6040866102f0919061136b565b6102fa919061136b565b1461033a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103319061149e565b60405180910390fd5b898990506020808361034c91906113ce565b61035691906113ff565b604084610363919061136b565b61036d919061136b565b146103ad576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103a49061150a565b60405180910390fd5b5050505092959194509250565b60003660003660006103ec888061014001906103d69190611539565b60619080926103e79392919061128a565b6101a7565b93509350935093506104028888868686866104ad565b9450505050509392505050565b600061041961046e565b60000160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff169050919050565b60008060017f6da8a1d7d4f224b5b2581a964c1890eb7e987638c691727e5a2a14ca24d03fd960001c6104a1919061159c565b60001b90508091505090565b60008085856000906014926104c49392919061128a565b906104cf91906115fc565b60601c90506104dc61046e565b60000160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161561056a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610561906116a7565b60405180910390fd5b600086866014906034926105809392919061128a565b9061058b91906112dd565b90506000801b81036105b45784846021906062926105ab9392919061128a565b9450945061091a565b6000858560008181106105ca576105c96116c7565b5b9050013560f81c60f81b60f81c90506060600060148360ff16036106f55787876001906015926105fc9392919061128a565b60405161060a929190611726565b60405180910390209050878760569080926106279392919061128a565b810190610634919061187d565b9150878760019060159261064a9392919061128a565b604051610658929190611726565b60405180910390208c80606001906106709190611539565b6010906024926106829392919061128a565b604051610690929190611726565b6040518091039020146106d8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106cf90611912565b60405180910390fd5b87876015906056926106ec9392919061128a565b975097506108cc565b60188360ff16036108cb5787876001906019926107149392919061128a565b604051610722929190611726565b604051809103902090508787605a90809261073f9392919061128a565b81019061074c919061187d565b915087876001906015926107629392919061128a565b604051610770929190611726565b60405180910390208c80606001906107889190611539565b60109060249261079a9392919061128a565b6040516107a8929190611726565b6040518091039020146107f0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107e790611912565b60405180910390fd5b60008c80606001906108029190611539565b6044906064926108149392919061128a565b9061081f91906112dd565b60001c90503660008e80606001906108379190611539565b602485610844919061136b565b90602886610852919061136b565b9261085f9392919061128a565b915091508a8a6015906019926108779392919061128a565b604051610885929190611726565b6040518091039020828260405161089d929190611932565b6040518091039020146108af57600080fd5b8a8a601990605a926108c39392919061128a565b9a509a505050505b5b6108d7828583610a50565b610916576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161090d90611997565b60405180910390fd5b5050505b60006109737ff0a98eef9608fd8bfe5833dfbc8b73ab86d0355db37a1f539565c5985ad1c2428a8c60200135604051602001610958939291906119d5565b60405160208183030381529060405280519060200120610a67565b905060006109ce87878080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505083610a8190919063ffffffff16565b90508373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610a3e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a3590611a58565b60405180910390fd5b60019450505050509695505050505050565b600082610a5d8584610aa8565b1490509392505050565b6000610a7a610a74610afe565b83610c18565b9050919050565b6000806000610a908585610c4b565b91509150610a9d81610c9c565b819250505092915050565b60008082905060005b8451811015610af357610ade82868381518110610ad157610ad06116c7565b5b6020026020010151610e02565b91508080610aeb90611a78565b915050610ab1565b508091505092915050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16148015610b7a57507f000000000000000000000000000000000000000000000000000000000000000046145b15610ba7577f00000000000000000000000000000000000000000000000000000000000000009050610c15565b610c127f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000610e2d565b90505b90565b60008282604051602001610c2d929190611b38565b60405160208183030381529060405280519060200120905092915050565b6000806041835103610c8c5760008060006020860151925060408601519150606086015160001a9050610c8087828585610e67565b94509450505050610c95565b60006002915091505b9250929050565b60006004811115610cb057610caf611b6f565b5b816004811115610cc357610cc2611b6f565b5b0315610dff5760016004811115610cdd57610cdc611b6f565b5b816004811115610cf057610cef611b6f565b5b03610d30576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d2790611bea565b60405180910390fd5b60026004811115610d4457610d43611b6f565b5b816004811115610d5757610d56611b6f565b5b03610d97576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d8e90611c56565b60405180910390fd5b60036004811115610dab57610daa611b6f565b5b816004811115610dbe57610dbd611b6f565b5b03610dfe576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610df590611ce8565b60405180910390fd5b5b50565b6000818310610e1a57610e158284610f49565b610e25565b610e248383610f49565b5b905092915050565b60008383834630604051602001610e48959493929190611d17565b6040516020818303038152906040528051906020012090509392505050565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08360001c1115610ea2576000600391509150610f40565b600060018787878760405160008152602001604052604051610ec79493929190611d86565b6020604051602081039080840390855afa158015610ee9573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610f3757600060019250925050610f40565b80600092509250505b94509492505050565b600082600052816020526040600020905092915050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610f9f82610f74565b9050919050565b610faf81610f94565b8114610fba57600080fd5b50565b600081359050610fcc81610fa6565b92915050565b600060208284031215610fe857610fe7610f6a565b5b6000610ff684828501610fbd565b91505092915050565b600080fd5b600080fd5b600080fd5b60008083601f84011261102457611023610fff565b5b8235905067ffffffffffffffff81111561104157611040611004565b5b60208301915083600182028301111561105d5761105c611009565b5b9250929050565b6000806020838503121561107b5761107a610f6a565b5b600083013567ffffffffffffffff81111561109957611098610f6f565b5b6110a58582860161100e565b92509250509250929050565b600082825260208201905092915050565b82818337600083830152505050565b6000601f19601f8301169050919050565b60006110ee83856110b1565b93506110fb8385846110c2565b611104836110d1565b840190509392505050565b6000604082019050818103600083015261112a8186886110e2565b9050818103602083015261113f8184866110e2565b905095945050505050565b600080fd5b600061016082840312156111665761116561114a565b5b81905092915050565b6000819050919050565b6111828161116f565b811461118d57600080fd5b50565b60008135905061119f81611179565b92915050565b6000819050919050565b6111b8816111a5565b81146111c357600080fd5b50565b6000813590506111d5816111af565b92915050565b6000806000606084860312156111f4576111f3610f6a565b5b600084013567ffffffffffffffff81111561121257611211610f6f565b5b61121e8682870161114f565b935050602061122f86828701611190565b9250506040611240868287016111c6565b9150509250925092565b60008115159050919050565b61125f8161124a565b82525050565b600060208201905061127a6000830184611256565b92915050565b600080fd5b600080fd5b6000808585111561129e5761129d611280565b5b838611156112af576112ae611285565b5b6001850283019150848603905094509492505050565b600082905092915050565b600082821b905092915050565b60006112e983836112c5565b826112f4813561116f565b925060208210156113345761132f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff836020036008026112d0565b831692505b505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611376826111a5565b9150611381836111a5565b92508282019050808211156113995761139861133c565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006113d9826111a5565b91506113e4836111a5565b9250826113f4576113f361139f565b5b828204905092915050565b600061140a826111a5565b9150611415836111a5565b9250828202611423816111a5565b9150828204841483151761143a5761143961133c565b5b5092915050565b600082825260208201905092915050565b7f696e76616c696420646174610000000000000000000000000000000000000000600082015250565b6000611488600c83611441565b915061149382611452565b602082019050919050565b600060208201905081810360008301526114b78161147b565b9050919050565b7f696e76616c6964207369676e6174757265000000000000000000000000000000600082015250565b60006114f4601183611441565b91506114ff826114be565b602082019050919050565b60006020820190508181036000830152611523816114e7565b9050919050565b600080fd5b600080fd5b600080fd5b600080833560016020038436030381126115565761155561152a565b5b80840192508235915067ffffffffffffffff8211156115785761157761152f565b5b60208301925060018202360383131561159457611593611534565b5b509250929050565b60006115a7826111a5565b91506115b2836111a5565b92508282039050818111156115ca576115c961133c565b5b92915050565b60007fffffffffffffffffffffffffffffffffffffffff00000000000000000000000082169050919050565b600061160883836112c5565b8261161381356115d0565b925060148210156116535761164e7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000836014036008026112d0565b831692505b505092915050565b7f73657373696f6e206b6579207265766f6b656400000000000000000000000000600082015250565b6000611691601383611441565b915061169c8261165b565b602082019050919050565b600060208201905081810360008301526116c081611684565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600081905092915050565b600061170d83856116f6565b935061171a8385846110c2565b82840190509392505050565b6000611733828486611701565b91508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b611777826110d1565b810181811067ffffffffffffffff821117156117965761179561173f565b5b80604052505050565b60006117a9610f60565b90506117b5828261176e565b919050565b600067ffffffffffffffff8211156117d5576117d461173f565b5b602082029050602081019050919050565b60006117f96117f4846117ba565b61179f565b9050808382526020820190506020840283018581111561181c5761181b611009565b5b835b8181101561184557806118318882611190565b84526020840193505060208101905061181e565b5050509392505050565b600082601f83011261186457611863610fff565b5b81356118748482602086016117e6565b91505092915050565b60006020828403121561189357611892610f6a565b5b600082013567ffffffffffffffff8111156118b1576118b0610f6f565b5b6118bd8482850161184f565b91505092915050565b7f696e76616c69642073657373696f6e206b657900000000000000000000000000600082015250565b60006118fc601383611441565b9150611907826118c6565b602082019050919050565b6000602082019050818103600083015261192b816118ef565b9050919050565b600061193f828486611701565b91508190509392505050565b7f696e76616c696465206d65726b6c6520726f6f74000000000000000000000000600082015250565b6000611981601483611441565b915061198c8261194b565b602082019050919050565b600060208201905081810360008301526119b081611974565b9050919050565b6119c08161116f565b82525050565b6119cf816111a5565b82525050565b60006060820190506119ea60008301866119b7565b6119f760208301856119b7565b611a0460408301846119c6565b949350505050565b7f6163636f756e743a20696e76616c6964207369676e6174757265000000000000600082015250565b6000611a42601a83611441565b9150611a4d82611a0c565b602082019050919050565b60006020820190508181036000830152611a7181611a35565b9050919050565b6000611a83826111a5565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611ab557611ab461133c565b5b600182019050919050565b600081905092915050565b7f1901000000000000000000000000000000000000000000000000000000000000600082015250565b6000611b01600283611ac0565b9150611b0c82611acb565b600282019050919050565b6000819050919050565b611b32611b2d8261116f565b611b17565b82525050565b6000611b4382611af4565b9150611b4f8285611b21565b602082019150611b5f8284611b21565b6020820191508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f45434453413a20696e76616c6964207369676e61747572650000000000000000600082015250565b6000611bd4601883611441565b9150611bdf82611b9e565b602082019050919050565b60006020820190508181036000830152611c0381611bc7565b9050919050565b7f45434453413a20696e76616c6964207369676e6174757265206c656e67746800600082015250565b6000611c40601f83611441565b9150611c4b82611c0a565b602082019050919050565b60006020820190508181036000830152611c6f81611c33565b9050919050565b7f45434453413a20696e76616c6964207369676e6174757265202773272076616c60008201527f7565000000000000000000000000000000000000000000000000000000000000602082015250565b6000611cd2602283611441565b9150611cdd82611c76565b604082019050919050565b60006020820190508181036000830152611d0181611cc5565b9050919050565b611d1181610f94565b82525050565b600060a082019050611d2c60008301886119b7565b611d3960208301876119b7565b611d4660408301866119b7565b611d5360608301856119c6565b611d606080830184611d08565b9695505050505050565b600060ff82169050919050565b611d8081611d6a565b82525050565b6000608082019050611d9b60008301876119b7565b611da86020830186611d77565b611db560408301856119b7565b611dc260608301846119b7565b9594505050505056fea26469706673582212205d61a7056fe6bfe6f67806ccdffcd495a3b016728c92d497f976c9d84670b56a64736f6c63430008120033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c806384f4fc6a14610051578063970aa9ad1461006d5780639e2045ce146100a0578063fa01dc06146100d0575b600080fd5b61006b60048036038101906100669190610fd2565b610100565b005b61008760048036038101906100829190611064565b6101a7565b604051610097949392919061110f565b60405180910390f35b6100ba60048036038101906100b591906111db565b6103ba565b6040516100c79190611265565b60405180910390f35b6100ea60048036038101906100e59190610fd2565b61040f565b6040516100f79190611265565b60405180910390f35b600161010a61046e565b60000160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508073ffffffffffffffffffffffffffffffffffffffff167f17c796fb82086b3c9effaec517342e5ca9ed8fd78c339137ec082f748ab60cbe60405160405180910390a250565b3660003660008086866000906020926101c29392919061128a565b906101cd91906112dd565b60001c90506000878783906020856101e5919061136b565b926101f29392919061128a565b906101fd91906112dd565b60001c9050600088886020906040926102189392919061128a565b9061022391906112dd565b60001c905060008989839060208561023b919061136b565b926102489392919061128a565b9061025391906112dd565b60001c90508989602086610267919061136b565b9085602088610276919061136b565b610280919061136b565b9261028d9392919061128a565b9750975089896020846102a0919061136b565b90836020866102af919061136b565b6102b9919061136b565b926102c69392919061128a565b9550955081602080856102d991906113ce565b6102e391906113ff565b6040866102f0919061136b565b6102fa919061136b565b1461033a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103319061149e565b60405180910390fd5b898990506020808361034c91906113ce565b61035691906113ff565b604084610363919061136b565b61036d919061136b565b146103ad576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103a49061150a565b60405180910390fd5b5050505092959194509250565b60003660003660006103ec888061014001906103d69190611539565b60619080926103e79392919061128a565b6101a7565b93509350935093506104028888868686866104ad565b9450505050509392505050565b600061041961046e565b60000160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff169050919050565b60008060017f6da8a1d7d4f224b5b2581a964c1890eb7e987638c691727e5a2a14ca24d03fd960001c6104a1919061159c565b60001b90508091505090565b60008085856000906014926104c49392919061128a565b906104cf91906115fc565b60601c90506104dc61046e565b60000160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161561056a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610561906116a7565b60405180910390fd5b600086866014906034926105809392919061128a565b9061058b91906112dd565b90506000801b81036105b45784846021906062926105ab9392919061128a565b9450945061091a565b6000858560008181106105ca576105c96116c7565b5b9050013560f81c60f81b60f81c90506060600060148360ff16036106f55787876001906015926105fc9392919061128a565b60405161060a929190611726565b60405180910390209050878760569080926106279392919061128a565b810190610634919061187d565b9150878760019060159261064a9392919061128a565b604051610658929190611726565b60405180910390208c80606001906106709190611539565b6010906024926106829392919061128a565b604051610690929190611726565b6040518091039020146106d8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106cf90611912565b60405180910390fd5b87876015906056926106ec9392919061128a565b975097506108cc565b60188360ff16036108cb5787876001906019926107149392919061128a565b604051610722929190611726565b604051809103902090508787605a90809261073f9392919061128a565b81019061074c919061187d565b915087876001906015926107629392919061128a565b604051610770929190611726565b60405180910390208c80606001906107889190611539565b60109060249261079a9392919061128a565b6040516107a8929190611726565b6040518091039020146107f0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107e790611912565b60405180910390fd5b60008c80606001906108029190611539565b6044906064926108149392919061128a565b9061081f91906112dd565b60001c90503660008e80606001906108379190611539565b602485610844919061136b565b90602886610852919061136b565b9261085f9392919061128a565b915091508a8a6015906019926108779392919061128a565b604051610885929190611726565b6040518091039020828260405161089d929190611932565b6040518091039020146108af57600080fd5b8a8a601990605a926108c39392919061128a565b9a509a505050505b5b6108d7828583610a50565b610916576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161090d90611997565b60405180910390fd5b5050505b60006109737ff0a98eef9608fd8bfe5833dfbc8b73ab86d0355db37a1f539565c5985ad1c2428a8c60200135604051602001610958939291906119d5565b60405160208183030381529060405280519060200120610a67565b905060006109ce87878080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505083610a8190919063ffffffff16565b90508373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610a3e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a3590611a58565b60405180910390fd5b60019450505050509695505050505050565b600082610a5d8584610aa8565b1490509392505050565b6000610a7a610a74610afe565b83610c18565b9050919050565b6000806000610a908585610c4b565b91509150610a9d81610c9c565b819250505092915050565b60008082905060005b8451811015610af357610ade82868381518110610ad157610ad06116c7565b5b6020026020010151610e02565b91508080610aeb90611a78565b915050610ab1565b508091505092915050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16148015610b7a57507f000000000000000000000000000000000000000000000000000000000000000046145b15610ba7577f00000000000000000000000000000000000000000000000000000000000000009050610c15565b610c127f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000610e2d565b90505b90565b60008282604051602001610c2d929190611b38565b60405160208183030381529060405280519060200120905092915050565b6000806041835103610c8c5760008060006020860151925060408601519150606086015160001a9050610c8087828585610e67565b94509450505050610c95565b60006002915091505b9250929050565b60006004811115610cb057610caf611b6f565b5b816004811115610cc357610cc2611b6f565b5b0315610dff5760016004811115610cdd57610cdc611b6f565b5b816004811115610cf057610cef611b6f565b5b03610d30576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d2790611bea565b60405180910390fd5b60026004811115610d4457610d43611b6f565b5b816004811115610d5757610d56611b6f565b5b03610d97576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d8e90611c56565b60405180910390fd5b60036004811115610dab57610daa611b6f565b5b816004811115610dbe57610dbd611b6f565b5b03610dfe576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610df590611ce8565b60405180910390fd5b5b50565b6000818310610e1a57610e158284610f49565b610e25565b610e248383610f49565b5b905092915050565b60008383834630604051602001610e48959493929190611d17565b6040516020818303038152906040528051906020012090509392505050565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08360001c1115610ea2576000600391509150610f40565b600060018787878760405160008152602001604052604051610ec79493929190611d86565b6020604051602081039080840390855afa158015610ee9573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610f3757600060019250925050610f40565b80600092509250505b94509492505050565b600082600052816020526040600020905092915050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610f9f82610f74565b9050919050565b610faf81610f94565b8114610fba57600080fd5b50565b600081359050610fcc81610fa6565b92915050565b600060208284031215610fe857610fe7610f6a565b5b6000610ff684828501610fbd565b91505092915050565b600080fd5b600080fd5b600080fd5b60008083601f84011261102457611023610fff565b5b8235905067ffffffffffffffff81111561104157611040611004565b5b60208301915083600182028301111561105d5761105c611009565b5b9250929050565b6000806020838503121561107b5761107a610f6a565b5b600083013567ffffffffffffffff81111561109957611098610f6f565b5b6110a58582860161100e565b92509250509250929050565b600082825260208201905092915050565b82818337600083830152505050565b6000601f19601f8301169050919050565b60006110ee83856110b1565b93506110fb8385846110c2565b611104836110d1565b840190509392505050565b6000604082019050818103600083015261112a8186886110e2565b9050818103602083015261113f8184866110e2565b905095945050505050565b600080fd5b600061016082840312156111665761116561114a565b5b81905092915050565b6000819050919050565b6111828161116f565b811461118d57600080fd5b50565b60008135905061119f81611179565b92915050565b6000819050919050565b6111b8816111a5565b81146111c357600080fd5b50565b6000813590506111d5816111af565b92915050565b6000806000606084860312156111f4576111f3610f6a565b5b600084013567ffffffffffffffff81111561121257611211610f6f565b5b61121e8682870161114f565b935050602061122f86828701611190565b9250506040611240868287016111c6565b9150509250925092565b60008115159050919050565b61125f8161124a565b82525050565b600060208201905061127a6000830184611256565b92915050565b600080fd5b600080fd5b6000808585111561129e5761129d611280565b5b838611156112af576112ae611285565b5b6001850283019150848603905094509492505050565b600082905092915050565b600082821b905092915050565b60006112e983836112c5565b826112f4813561116f565b925060208210156113345761132f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff836020036008026112d0565b831692505b505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611376826111a5565b9150611381836111a5565b92508282019050808211156113995761139861133c565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006113d9826111a5565b91506113e4836111a5565b9250826113f4576113f361139f565b5b828204905092915050565b600061140a826111a5565b9150611415836111a5565b9250828202611423816111a5565b9150828204841483151761143a5761143961133c565b5b5092915050565b600082825260208201905092915050565b7f696e76616c696420646174610000000000000000000000000000000000000000600082015250565b6000611488600c83611441565b915061149382611452565b602082019050919050565b600060208201905081810360008301526114b78161147b565b9050919050565b7f696e76616c6964207369676e6174757265000000000000000000000000000000600082015250565b60006114f4601183611441565b91506114ff826114be565b602082019050919050565b60006020820190508181036000830152611523816114e7565b9050919050565b600080fd5b600080fd5b600080fd5b600080833560016020038436030381126115565761155561152a565b5b80840192508235915067ffffffffffffffff8211156115785761157761152f565b5b60208301925060018202360383131561159457611593611534565b5b509250929050565b60006115a7826111a5565b91506115b2836111a5565b92508282039050818111156115ca576115c961133c565b5b92915050565b60007fffffffffffffffffffffffffffffffffffffffff00000000000000000000000082169050919050565b600061160883836112c5565b8261161381356115d0565b925060148210156116535761164e7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000836014036008026112d0565b831692505b505092915050565b7f73657373696f6e206b6579207265766f6b656400000000000000000000000000600082015250565b6000611691601383611441565b915061169c8261165b565b602082019050919050565b600060208201905081810360008301526116c081611684565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600081905092915050565b600061170d83856116f6565b935061171a8385846110c2565b82840190509392505050565b6000611733828486611701565b91508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b611777826110d1565b810181811067ffffffffffffffff821117156117965761179561173f565b5b80604052505050565b60006117a9610f60565b90506117b5828261176e565b919050565b600067ffffffffffffffff8211156117d5576117d461173f565b5b602082029050602081019050919050565b60006117f96117f4846117ba565b61179f565b9050808382526020820190506020840283018581111561181c5761181b611009565b5b835b8181101561184557806118318882611190565b84526020840193505060208101905061181e565b5050509392505050565b600082601f83011261186457611863610fff565b5b81356118748482602086016117e6565b91505092915050565b60006020828403121561189357611892610f6a565b5b600082013567ffffffffffffffff8111156118b1576118b0610f6f565b5b6118bd8482850161184f565b91505092915050565b7f696e76616c69642073657373696f6e206b657900000000000000000000000000600082015250565b60006118fc601383611441565b9150611907826118c6565b602082019050919050565b6000602082019050818103600083015261192b816118ef565b9050919050565b600061193f828486611701565b91508190509392505050565b7f696e76616c696465206d65726b6c6520726f6f74000000000000000000000000600082015250565b6000611981601483611441565b915061198c8261194b565b602082019050919050565b600060208201905081810360008301526119b081611974565b9050919050565b6119c08161116f565b82525050565b6119cf816111a5565b82525050565b60006060820190506119ea60008301866119b7565b6119f760208301856119b7565b611a0460408301846119c6565b949350505050565b7f6163636f756e743a20696e76616c6964207369676e6174757265000000000000600082015250565b6000611a42601a83611441565b9150611a4d82611a0c565b602082019050919050565b60006020820190508181036000830152611a7181611a35565b9050919050565b6000611a83826111a5565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611ab557611ab461133c565b5b600182019050919050565b600081905092915050565b7f1901000000000000000000000000000000000000000000000000000000000000600082015250565b6000611b01600283611ac0565b9150611b0c82611acb565b600282019050919050565b6000819050919050565b611b32611b2d8261116f565b611b17565b82525050565b6000611b4382611af4565b9150611b4f8285611b21565b602082019150611b5f8284611b21565b6020820191508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f45434453413a20696e76616c6964207369676e61747572650000000000000000600082015250565b6000611bd4601883611441565b9150611bdf82611b9e565b602082019050919050565b60006020820190508181036000830152611c0381611bc7565b9050919050565b7f45434453413a20696e76616c6964207369676e6174757265206c656e67746800600082015250565b6000611c40601f83611441565b9150611c4b82611c0a565b602082019050919050565b60006020820190508181036000830152611c6f81611c33565b9050919050565b7f45434453413a20696e76616c6964207369676e6174757265202773272076616c60008201527f7565000000000000000000000000000000000000000000000000000000000000602082015250565b6000611cd2602283611441565b9150611cdd82611c76565b604082019050919050565b60006020820190508181036000830152611d0181611cc5565b9050919050565b611d1181610f94565b82525050565b600060a082019050611d2c60008301886119b7565b611d3960208301876119b7565b611d4660408301866119b7565b611d5360608301856119c6565b611d606080830184611d08565b9695505050505050565b600060ff82169050919050565b611d8081611d6a565b82525050565b6000608082019050611d9b60008301876119b7565b611da86020830186611d77565b611db560408301856119b7565b611dc260608301846119b7565b9594505050505056fea26469706673582212205d61a7056fe6bfe6f67806ccdffcd495a3b016728c92d497f976c9d84670b56a64736f6c63430008120033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}